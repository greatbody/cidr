<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VNet IP Usage Visualizer</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f4f7f9;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            background-color: #fff;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 1000px;
            margin-bottom: 20px;
        }

        h1,
        h2 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 20px;
        }

        .vnet-info,
        .subnet-details-header {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e0e0e0;
        }

        .vnet-info p,
        .subnet-details-header p {
            margin: 5px 0;
            font-size: 1.1em;
        }

        .vnet-info strong,
        .subnet-details-header strong {
            color: #3498db;
        }

        .visualization-area {
            width: 100%;
            height: 60px;
            background-color: #ecf0f1;
            border-radius: 5px;
            position: relative;
            margin-bottom: 20px;
            overflow: hidden;
            cursor: grab;
        }

        .visualization-area.dragging {
            cursor: grabbing;
        }

        #ipBlocksWrapper {
            display: flex;
            height: 100%;
            min-width: 100%;
            transform-origin: 0 0;
            /* IMPORTANT: Scale from the left edge */
            /* transition: transform 0.05s linear; /* Optional: for slightly smoother zoom, but can feel laggy */
        }

        .ip-block {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
            color: white;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.2);
            box-sizing: border-box;
            border-right: 1px solid rgba(255, 255, 255, 0.2);
            /* transition: opacity 0.2s ease-in-out; /* Opacity transition is fine */
            flex-shrink: 0;
        }

        .ip-block:last-child {
            border-right: none;
        }

        .ip-block:hover {
            opacity: 0.85;
        }

        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.9em;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s, transform 0.2s;
            z-index: 100;
            white-space: nowrap;
            transform: translate(-50%, -110%);
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 5px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 10px;
            font-size: 0.9em;
        }

        .legend-color-box {
            width: 15px;
            height: 15px;
            margin-right: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
            font-size: 0.95em;
        }

        th {
            background-color: #3498db;
            color: white;
        }

        tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        .error-message {
            color: red;
            font-weight: bold;
            text-align: center;
            margin-top: 10px;
        }
    </style>
</head>

<body>

    <div class="container">
        <h2>Configuration</h2>
        <div style="margin-bottom: 10px;">
            <label for="vnetCidrInput">VNet CIDR:</label>
            <input type="text" id="vnetCidrInput" placeholder="e.g., 10.0.0.0/16"
                style="margin-left: 5px; padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
            <button id="updateVnetButton"
                style="margin-left: 10px; padding: 5px 10px; background-color: #3498db; color: white; border: none; border-radius: 3px; cursor: pointer;">Update
                VNet</button>
            <button id="resetDataButton"
                style="margin-left: 10px; padding: 5px 10px; background-color: #e74c3c; color: white; border: none; border-radius: 3px; cursor: pointer;">Reset
                to Defaults</button>
        </div>
    </div>

    <h1>VNet IP Address Usage Visualizer</h1>

    <div class="container">
        <h2>VNet Overview</h2>
        <div class="vnet-info" id="vnetInfo"></div>
        <div class="visualization-area" id="visualizationArea">
            <div id="ipBlocksWrapper">
                <!-- IP blocks will be rendered here -->
            </div>
        </div>
        <div class="legend" id="legend"></div>
        <div id="errorMessage" class="error-message"></div>
    </div>

    <div class="container">
        <h2>Subnet Details</h2>
        <table id="subnetTable">
            <thead>
                <tr>
                    <th>Name</th>
                    <th>CIDR</th>
                    <th>IP Range</th>
                    <th>Total IPs</th>
                    <th>% of VNet</th>
                </tr>
            </thead>
            <tbody id="subnetTableBody"></tbody>
        </table>
    </div>

    <div class="container">
        <h2>Manage Subnets</h2>
        <div id="manageSubnetsList" style="margin-bottom: 15px;">
            <!-- Subnets will be listed here for management -->
        </div>
        <div>
            <input type="text" id="newSubnetNameInput" placeholder="Subnet Name"
                style="padding: 5px; border: 1px solid #ccc; border-radius: 3px; margin-right: 5px;">
            <input type="text" id="newSubnetCidrInput" placeholder="Subnet CIDR (e.g., 10.0.1.0/24)"
                style="padding: 5px; border: 1px solid #ccc; border-radius: 3px; margin-right: 5px;">
            <button id="addSubnetButton"
                style="padding: 5px 10px; background-color: #2ecc71; color: white; border: none; border-radius: 3px; cursor: pointer;">Add
                Subnet</button>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

<script>
    // --- Configuration ---
    // Default configuration that will be used if no data in localStorage
    const DEFAULT_CONFIG = {
        vnetCidr: "10.0.0.0/8",
        subnets: [
            { name: "default", cidr: "10.0.0.1/24" },
        ]
    };

    // Define missing constants
    const SUBNET_COLORS = [
        '#3498db', '#2ecc71', '#e74c3c', '#f1c40f', '#9b59b6',
        '#1abc9c', '#e67e22', '#34495e', '#27ae60', '#c0392b',
        '#2980b9', '#8e44ad', '#16a085', '#d35400', '#7f8c8d'
    ];
    const GAP_COLOR = '#ecf0f1';

    // Load stored data or use defaults
    let config = JSON.parse(localStorage.getItem('vnetConfig')) || DEFAULT_CONFIG;

    // Function to validate CIDR format
    function isValidCidr(cidr) {
        const cidrRegex = /^(\d{1,3}\.){3}\d{1,3}\/\d{1,2}$/;
        if (!cidrRegex.test(cidr)) return false;

        const [ip, prefix] = cidr.split('/');
        const prefixNum = parseInt(prefix);
        if (prefixNum < 0 || prefixNum > 32) return false;

        const octets = ip.split('.');
        return octets.every(octet => {
            const num = parseInt(octet);
            return num >= 0 && num <= 255;
        });
    }

    // Function to save config to localStorage
    function saveConfig() {
        localStorage.setItem('vnetConfig', JSON.stringify(config));
    }

    // Function to update the visualization
    function updateVisualization() {
        // Clear any existing content
        document.getElementById('vnetInfo').innerHTML = '';
        document.getElementById('ipBlocksWrapper').innerHTML = '';
        document.getElementById('legend').innerHTML = '';
        document.getElementById('subnetTableBody').innerHTML = '';
        document.getElementById('errorMessage').innerHTML = '';
        document.getElementById('manageSubnetsList').innerHTML = '';
        
        let errorMessages = [];

        // Update VNet CIDR input
        document.getElementById('vnetCidrInput').value = config.vnetCidr;

        // Update manage subnets list
        const manageSubnetsList = document.getElementById('manageSubnetsList');
        config.subnets.forEach((subnet, index) => {
            const subnetDiv = document.createElement('div');
            subnetDiv.style.marginBottom = '10px';
            subnetDiv.style.display = 'flex';
            subnetDiv.style.alignItems = 'center';
            subnetDiv.style.gap = '10px';

            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.value = subnet.name;
            nameInput.style.padding = '5px';
            nameInput.style.borderRadius = '3px';
            nameInput.style.border = '1px solid #ccc';

            const cidrInput = document.createElement('input');
            cidrInput.type = 'text';
            cidrInput.value = subnet.cidr;
            cidrInput.style.padding = '5px';
            cidrInput.style.borderRadius = '3px';
            cidrInput.style.border = '1px solid #ccc';

            const updateButton = document.createElement('button');
            updateButton.textContent = 'Update';
            updateButton.style.padding = '5px 10px';
            updateButton.style.backgroundColor = '#3498db';
            updateButton.style.color = 'white';
            updateButton.style.border = 'none';
            updateButton.style.borderRadius = '3px';
            updateButton.style.cursor = 'pointer';

            const deleteButton = document.createElement('button');
            deleteButton.textContent = 'Delete';
            deleteButton.style.padding = '5px 10px';
            deleteButton.style.backgroundColor = '#e74c3c';
            deleteButton.style.color = 'white';
            deleteButton.style.border = 'none';
            deleteButton.style.borderRadius = '3px';
            deleteButton.style.cursor = 'pointer';

            updateButton.addEventListener('click', () => {
                if (!isValidCidr(cidrInput.value)) {
                    alert('Invalid CIDR format');
                    return;
                }
                config.subnets[index] = {
                    name: nameInput.value,
                    cidr: cidrInput.value
                };
                saveConfig();
                updateVisualization();
            });

            deleteButton.addEventListener('click', () => {
                if (confirm('Are you sure you want to delete this subnet?')) {
                    config.subnets.splice(index, 1);
                    saveConfig();
                    updateVisualization();
                }
            });

            subnetDiv.appendChild(nameInput);
            subnetDiv.appendChild(cidrInput);
            subnetDiv.appendChild(updateButton);
            subnetDiv.appendChild(deleteButton);
            manageSubnetsList.appendChild(subnetDiv);
        });

        // Continue with the existing visualization logic...
        try {
            const vnet = { ...cidrToRange(config.vnetCidr), name: "VNet" };
            VNET_INFO_GLOBAL = vnet; // Store for global access by text updater
            document.getElementById('vnetInfo').innerHTML = `
                <p><strong>VNet CIDR:</strong> ${vnet.cidr}</p>
                <p><strong>IP Range:</strong> ${vnet.networkAddress} - ${vnet.broadcastAddress}</p>
                <p><strong>Total IPs:</strong> ${vnet.numAddresses.toLocaleString()}</p>
            `;

            const processedSubnets = config.subnets.map((subnetData, index) => {
                try {
                    const range = cidrToRange(subnetData.cidr);
                    if (range.startIpLong < vnet.startIpLong || range.endIpLong > vnet.endIpLong) {
                        errorMessages.push(`Error: Subnet ${subnetData.name} (${subnetData.cidr}) is outside the VNet range.`);
                        return null;
                    }
                    return {
                        ...subnetData,
                        ...range,
                        color: SUBNET_COLORS[index % SUBNET_COLORS.length]
                    };
                } catch (e) {
                    errorMessages.push(`Error processing subnet ${subnetData.name} (${subnetData.cidr}): ${e.message}`);
                    return null;
                }
            }).filter(s => s !== null);

            processedSubnets.sort((a, b) => a.startIpLong - b.startIpLong);

            for (let i = 0; i < processedSubnets.length - 1; i++) {
                if (processedSubnets[i].endIpLong >= processedSubnets[i + 1].startIpLong) {
                    errorMessages.push(`Error: Subnet ${processedSubnets[i].name} (${processedSubnets[i].cidr}) overlaps with ${processedSubnets[i + 1].name} (${processedSubnets[i + 1].cidr}).`);
                }
            }

            if (errorMessages.length > 0) {
                document.getElementById('errorMessage').innerHTML = errorMessages.join('<br>');
            }

            const displayBlocks = [];
            let currentIpLongVal = vnet.startIpLong;

            processedSubnets.forEach(subnet => {
                if (subnet.startIpLong > currentIpLongVal) {
                    displayBlocks.push({
                        name: "Unallocated", type: "gap", startIpLong: currentIpLongVal,
                        endIpLong: subnet.startIpLong - 1, numAddresses: (subnet.startIpLong - currentIpLongVal),
                        color: GAP_COLOR, cidr: `${longToIp(currentIpLongVal)} - ${longToIp(subnet.startIpLong - 1)}`
                    });
                }
                displayBlocks.push({ ...subnet, type: "subnet" });
                currentIpLongVal = subnet.endIpLong + 1;
            });

            if (currentIpLongVal <= vnet.endIpLong) {
                displayBlocks.push({
                    name: "Unallocated", type: "gap", startIpLong: currentIpLongVal,
                    endIpLong: vnet.endIpLong, numAddresses: (vnet.endIpLong - currentIpLongVal + 1),
                    color: GAP_COLOR, cidr: `${longToIp(currentIpLongVal)} - ${longToIp(vnet.endIpLong)}`
                });
            }

            const ipBlocksWrapper = document.getElementById('ipBlocksWrapper');
            ipBlocksWrapper.innerHTML = '';
            displayBlocks.forEach(block => {
                if (block.numAddresses <= 0) return;

                const blockDiv = document.createElement('div');
                blockDiv.classList.add('ip-block');
                blockDiv.style.backgroundColor = block.color;
                const widthPercentage = (block.numAddresses / vnet.numAddresses) * 100;
                blockDiv.style.width = `${widthPercentage}%`;

                block.widthPercentage = widthPercentage; // Store for text visibility updates
                blockDiv.ipBlockData = block; // Store all data on the element

                blockDiv.addEventListener('mousemove', (e) => {
                    const tooltip = document.getElementById('tooltip');
                    tooltip.style.opacity = '1';
                    tooltip.style.left = `${e.pageX}px`;
                    tooltip.style.top = `${e.pageY}px`;
                    let ipRangeStr = block.type === 'gap' ? `${longToIp(block.startIpLong)} - ${longToIp(block.endIpLong)}` : block.cidr;
                    tooltip.innerHTML = `
                        <strong>${block.name}</strong><br>
                        ${block.type === 'subnet' ? `CIDR: ${block.cidr}<br>` : ''}
                        Range: ${ipRangeStr}<br>
                        IPs: ${block.numAddresses.toLocaleString()} (${block.widthPercentage.toFixed(4)}%)
                    `;
                });
                blockDiv.addEventListener('mouseleave', () => {
                    const tooltip = document.getElementById('tooltip');
                    tooltip.style.opacity = '0';
                });

                ipBlocksWrapper.appendChild(blockDiv);
            });

            const legendDiv = document.getElementById('legend');
            legendDiv.innerHTML = '';
            const legendItems = {};
            processedSubnets.forEach(subnet => { if (!legendItems[subnet.name]) legendItems[subnet.name] = subnet.color; });
            if (displayBlocks.some(b => b.type === 'gap' && b.numAddresses > 0)) legendItems["Unallocated"] = GAP_COLOR;
            for (const name in legendItems) {
                const itemDiv = document.createElement('div');
                itemDiv.classList.add('legend-item');
                itemDiv.innerHTML = `<span class="legend-color-box" style="background-color: ${legendItems[name]};"></span> ${name}`;
                legendDiv.appendChild(itemDiv);
            }

            const subnetTableBody = document.getElementById('subnetTableBody');
            subnetTableBody.innerHTML = '';
            processedSubnets.forEach(subnet => {
                const row = subnetTableBody.insertRow();
                row.insertCell().textContent = subnet.name;
                row.insertCell().textContent = subnet.cidr;
                row.insertCell().textContent = `${subnet.networkAddress} - ${subnet.broadcastAddress}`;
                row.insertCell().textContent = subnet.numAddresses.toLocaleString();
                row.insertCell().textContent = `${((subnet.numAddresses / vnet.numAddresses) * 100).toFixed(2)}%`;
            });

        } catch (e) {
            console.error("Error initializing visualizer:", e);
            document.getElementById('errorMessage').textContent = `Fatal Error: ${e.message}. Check console for details.`;
        }
    }

    // --- Global VNet object ---
    let VNET_INFO_GLOBAL = null;

    // --- Helper Functions ---
    function ipToLong(ip) {
        return ip.split('.').reduce((acc, octet, index, arr) => {
            return acc + (parseInt(octet) * Math.pow(256, (arr.length - 1 - index)));
        }, 0);
    }

    function longToIp(long) {
        return [
            (long >>> 24) & 0xFF,
            (long >>> 16) & 0xFF,
            (long >>> 8) & 0xFF,
            long & 0xFF
        ].join('.');
    }

    function cidrToRange(cidr) {
        const [ip, prefixStr] = cidr.split('/');
        const prefix = parseInt(prefixStr);
        if (isNaN(prefix) || prefix < 0 || prefix > 32) {
            throw new Error(`Invalid CIDR prefix: ${cidr}`);
        }
        const ipLong = ipToLong(ip);
        const mask = (0xFFFFFFFF << (32 - prefix)) & 0xFFFFFFFF;
        const networkAddressLong = ipLong & mask;
        const broadcastAddressLong = networkAddressLong | (~mask & 0xFFFFFFFF);
        const numAddresses = Math.pow(2, 32 - prefix);
        return {
            cidr: cidr,
            networkAddress: longToIp(networkAddressLong >>> 0),
            broadcastAddress: longToIp(broadcastAddressLong >>> 0),
            startIpLong: networkAddressLong >>> 0,
            endIpLong: broadcastAddressLong >>> 0,
            numAddresses: numAddresses
        };
    }

    // --- Main Logic ---
    document.addEventListener('DOMContentLoaded', () => {
        // Initialize UI bindings
        const vnetCidrInput = document.getElementById('vnetCidrInput');
        const updateVnetButton = document.getElementById('updateVnetButton');
        const resetDataButton = document.getElementById('resetDataButton');
        const addSubnetButton = document.getElementById('addSubnetButton');
        const newSubnetNameInput = document.getElementById('newSubnetNameInput');
        const newSubnetCidrInput = document.getElementById('newSubnetCidrInput');

        // Initialize values
        vnetCidrInput.value = config.vnetCidr;

        // Add event listeners for the configuration controls
        updateVnetButton.addEventListener('click', () => {
            const newCidr = vnetCidrInput.value;
            if (!isValidCidr(newCidr)) {
                alert('Invalid CIDR format');
                return;
            }
            config.vnetCidr = newCidr;
            saveConfig();
            updateVisualization();
        });

        resetDataButton.addEventListener('click', () => {
            if (confirm('Are you sure you want to reset to default configuration?')) {
                config = {...DEFAULT_CONFIG};
                saveConfig();
                vnetCidrInput.value = config.vnetCidr;
                updateVisualization();
            }
        });

        addSubnetButton.addEventListener('click', () => {
            const name = newSubnetNameInput.value;
            const cidr = newSubnetCidrInput.value;
            
            if (!name || !cidr) {
                alert('Please provide both name and CIDR');
                return;
            }
            
            if (!isValidCidr(cidr)) {
                alert('Invalid CIDR format');
                return;
            }
            
            config.subnets.push({ name, cidr });
            saveConfig();
            
            // Clear inputs
            newSubnetNameInput.value = '';
            newSubnetCidrInput.value = '';
            
            updateVisualization();
        });

        const visualizationArea = document.getElementById('visualizationArea');
        const ipBlocksWrapper = document.getElementById('ipBlocksWrapper');
        const tooltip = document.getElementById('tooltip');

        let currentZoom = 1.0;
        let currentPanX = 0;
        const MIN_ZOOM = 0.1;
        const MAX_ZOOM = 100.0;  // Increased max zoom for very small subnets
        const ZOOM_SENSITIVITY = 0.1;

        let isDragging = false;
        let dragStartX = 0;
        let initialPanX = 0;

        function updateBlockTextVisibility() {
            if (!VNET_INFO_GLOBAL) return; // Ensure VNet info is available

            const blocks = ipBlocksWrapper.querySelectorAll('.ip-block');
            blocks.forEach(blockDiv => {
                const blockData = blockDiv.ipBlockData;
                if (!blockData) return;

                const apparentWidth = parseFloat(blockDiv.style.width); // Width is now in pixels

                // Original logic: only "Unallocated" shows text if its width is >= 60. All other names are cleared.
                if (blockData.name !== "Unallocated") {
                    blockDiv.textContent = '';
                } else { // It is "Unallocated"
                    if (apparentWidth < 60) {
                        blockDiv.textContent = '';
                    } else {
                        blockDiv.textContent = "Unallocated"; // Ensure it's set
                    }
                }
            });
        }

        function updateTransform() {
            const vizAreaWidth = visualizationArea.clientWidth;
            let totalBlocksWidth = 0;

            // 1. Update width of each block
            const blocks = ipBlocksWrapper.querySelectorAll('.ip-block');
            blocks.forEach(blockDiv => {
                const blockData = blockDiv.ipBlockData;
                if (!blockData) return;

                const baseBlockWidth = (blockData.widthPercentage / 100) * vizAreaWidth;
                const newWidth = baseBlockWidth * currentZoom;
                blockDiv.style.width = `${newWidth}px`;
                totalBlocksWidth += newWidth;
            });

            // 2. Update panning/positioning of the wrapper using marginLeft
            if (totalBlocksWidth <= vizAreaWidth) { // Content is smaller than or fits in view
                currentPanX = (vizAreaWidth - totalBlocksWidth) / 2; // Center the content
            } else { // Content is larger than view
                // Ensure pan stays within bounds
                currentPanX = Math.min(0, currentPanX); // Cannot pan further right than 0 (content starts at left edge)
                currentPanX = Math.max(vizAreaWidth - totalBlocksWidth, currentPanX); // Cannot pan further left than total width allows
            }
            ipBlocksWrapper.style.marginLeft = `${currentPanX}px`;
            ipBlocksWrapper.style.transform = ''; // Remove any transform scaling/translating

            updateBlockTextVisibility();
        }

        visualizationArea.addEventListener('wheel', (event) => {
            event.preventDefault();
            const rect = visualizationArea.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const oldZoom = currentZoom;

            // Mouse's position in the *unscaled content* relative to the start of ipBlocksWrapper's visible part
            const mousePointInContentBeforeZoom_Unscaled = (mouseX - currentPanX) / oldZoom;

            if (event.deltaY < 0) {
                currentZoom = Math.min(MAX_ZOOM, currentZoom * (1 + ZOOM_SENSITIVITY));
            } else {
                currentZoom = Math.max(MIN_ZOOM, currentZoom * (1 - ZOOM_SENSITIVITY));
            }

            // Adjust currentPanX so the point under the mouse remains the same after zoom
            currentPanX = mouseX - (mousePointInContentBeforeZoom_Unscaled * currentZoom);
            updateTransform();
        });

        visualizationArea.addEventListener('mousedown', (event) => {
            if (event.button !== 0) return;
            event.preventDefault(); // Prevent text selection during drag
            isDragging = true;
            dragStartX = event.clientX;
            initialPanX = currentPanX;
            visualizationArea.classList.add('dragging');
        });

        document.addEventListener('mousemove', (event) => {
            if (!isDragging) return;
            event.preventDefault();
            const deltaX = event.clientX - dragStartX;
            currentPanX = initialPanX + deltaX;
            updateTransform();
        });

        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                visualizationArea.classList.remove('dragging');
            }
        });

        document.addEventListener('mouseleave', (event) => {
            if (event.relatedTarget === null && isDragging) {
                isDragging = false;
                visualizationArea.classList.remove('dragging');
            }
        });

        // Initialize the visualization
        updateVisualization();
    });
</script>
</body>

</html>